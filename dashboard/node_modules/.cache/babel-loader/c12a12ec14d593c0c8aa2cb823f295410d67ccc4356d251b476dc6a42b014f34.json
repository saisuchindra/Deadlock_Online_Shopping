{"ast":null,"code":"import _objectSpread from\"C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState,useEffect,useCallback,useRef}from'react';import{generateInitialResources,generateInitialCustomers,generateEvent,generatePerformancePoint,generateWaitForGraph,generateStressData,randomPick,randomInt,EVENT_TYPES}from'../data/mockData';const TICK_INTERVAL=1200;const MAX_LOG_ENTRIES=200;const MAX_PERF_POINTS=60;const MAX_STRESS_POINTS=40;export function useSimulation(){const[isRunning,setIsRunning]=useState(false);const[tick,setTick]=useState(0);const tickRef=useRef(0);// Strategy toggles\nconst[preventionEnabled,setPreventionEnabled]=useState(false);const[avoidanceEnabled,setAvoidanceEnabled]=useState(false);const[detectionEnabled,setDetectionEnabled]=useState(true);const[stressTestActive,setStressTestActive]=useState(false);const[stressLevel,setStressLevel]=useState(5);// 1-10 scale\n// Active resource filter (empty Set = all active)\nconst[activeResourceIds,setActiveResourceIds]=useState(new Set());// Core state\nconst[resources,setResources]=useState(()=>generateInitialResources(8));const[customers,setCustomers]=useState(()=>generateInitialCustomers(6));const[eventLog,setEventLog]=useState([]);const[perfData,setPerfData]=useState([]);const[stressData,setStressData]=useState([]);const[graphData,setGraphData]=useState({nodes:[],edges:[]});// Aggregate metrics\nconst[systemStatus,setSystemStatus]=useState('idle');// idle, running, deadlock, recovery\nconst[deadlockCount,setDeadlockCount]=useState(0);const[recoveryCount,setRecoveryCount]=useState(0);const[totalGranted,setTotalGranted]=useState(0);const[totalDenied,setTotalDenied]=useState(0);const intervalRef=useRef(null);const systemStatusRef=useRef('idle');// Keep ref in sync so simulateTick reads current status (avoids stale closure)\nuseEffect(()=>{systemStatusRef.current=systemStatus;},[systemStatus]);const simulateTick=useCallback(()=>{tickRef.current+=1;const currentTick=tickRef.current;setTick(currentTick);setCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));updated.forEach(c=>{if(c.state==='idle'&&Math.random()>0.4){c.state='running';}});return updated;});setResources(prevResources=>{setCustomers(prevCustomers=>{const res=prevResources.map(r=>_objectSpread(_objectSpread({},r),{},{waitingThreads:[]}));const custs=prevCustomers.map(c=>_objectSpread(_objectSpread({},c),{},{holding:[...c.holding]}));// Determine which resources are active (empty set = all)\nconst activeSet=activeResourceIds;const isResActive=r=>activeSet.size===0||activeSet.has(r.id);// Simulate resource allocation\ncusts.forEach(c=>{if(c.state==='running'||c.state==='waiting'){const availableRes=res.filter(r=>isResActive(r)&&r.available&&!c.holding.includes(r.id));if(preventionEnabled){// PREVENTION: enforce resource ordering — only acquire resources with ID > max held\nconst maxHeldIdx=c.holding.length>0?Math.max(...c.holding.map(id=>parseInt(id.replace('R','')))):-1;const safeRes=availableRes.filter(r=>parseInt(r.id.replace('R',''))>maxHeldIdx);if(safeRes.length>0&&Math.random()>0.25){const target=randomPick(safeRes);target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}else if(c.holding.length===0&&availableRes.length>0&&Math.random()>0.3){const target=randomPick(availableRes);target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}// Prevention: never enter circular wait\n}else if(avoidanceEnabled){// AVOIDANCE: simplified Banker's check — deny if granting leaves system unsafe\nif(availableRes.length>0&&Math.random()>0.3){const target=randomPick(availableRes);const totalAvailableAfter=res.filter(r=>r.available).length-1;const waitingCount=custs.filter(c2=>c2.state==='waiting').length;if(totalAvailableAfter>=waitingCount||waitingCount===0){target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}}else if(Math.random()>0.5){const unavailable=res.filter(r=>isResActive(r)&&!r.available&&!c.holding.includes(r.id));if(unavailable.length>0){const target=randomPick(unavailable);target.waitingThreads.push(c.name);c.waiting=target.id;c.state='waiting';}}}else{// NO STRATEGY: normal allocation (can cause deadlocks)\nif(availableRes.length>0&&Math.random()>0.3){const target=randomPick(availableRes);target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}else if(Math.random()>0.5){const unavailable=res.filter(r=>isResActive(r)&&!r.available&&!c.holding.includes(r.id));if(unavailable.length>0){const target=randomPick(unavailable);target.waitingThreads.push(c.name);c.waiting=target.id;c.state='waiting';}}}}// Randomly release resources\nif(c.holding.length>0&&Math.random()>0.65){const releaseId=randomPick(c.holding);c.holding=c.holding.filter(id=>id!==releaseId);const released=res.find(r=>r.id===releaseId);if(released){released.available=true;released.owner=null;released.currentInstances=Math.max(0,released.currentInstances-1);}if(c.holding.length===0&&!c.waiting){c.state=Math.random()>0.3?'running':'idle';}}});setResources(res);return custs;});return prevResources;});// ---- Deadlock State Machine (uses ref to avoid stale closure) ----\nconst prevStatus=systemStatusRef.current;let newStatus=prevStatus;let didDeadlock=false;let didRecover=false;if(preventionEnabled||avoidanceEnabled){// Strategies active → no deadlocks possible; clear any leftover deadlocked state\nsetCustomers(prev=>prev.map(c=>c.state==='deadlocked'?_objectSpread(_objectSpread({},c),{},{state:'running',waiting:null}):c));newStatus=currentTick>1?'running':prevStatus;}else{// No strategies → deadlocks can occur\nconst shouldDeadlock=Math.random()>0.82;if(shouldDeadlock&&prevStatus!=='deadlock'){didDeadlock=true;setDeadlockCount(prev=>prev+1);newStatus='deadlock';setCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));const waiting=updated.filter(c=>c.state==='waiting');if(waiting.length>=2){waiting.slice(0,2).forEach(c=>{c.state='deadlocked';});}else{const running=updated.filter(c=>c.state==='running');running.slice(0,2).forEach(c=>{c.state='deadlocked';});}return updated;});}else if(prevStatus==='deadlock'){if(detectionEnabled){didRecover=true;setRecoveryCount(prev=>prev+1);newStatus='recovery';// Clear deadlocked customers and release their resources\nsetCustomers(prev=>prev.map(c=>c.state==='deadlocked'?_objectSpread(_objectSpread({},c),{},{state:'running',waiting:null,holding:[]}):c));setResources(prev=>prev.map(r=>_objectSpread(_objectSpread({},r),{},{available:true,owner:null,currentInstances:0,waitingThreads:[]})));setTimeout(()=>{setSystemStatus(s=>s==='recovery'?'running':s);},2500);}else{newStatus='deadlock';// Stuck — no detection to recover\n}}else if(prevStatus==='recovery'){newStatus='recovery';// Let timeout handle transition\n}else{newStatus=currentTick>1?'running':prevStatus;}}setSystemStatus(newStatus);// Generate events\nsetCustomers(prevCustomers=>{setResources(prevResources=>{const eventTypes=[EVENT_TYPES.REQUEST,EVENT_TYPES.ALLOCATE,EVENT_TYPES.RELEASE];if(didDeadlock)eventTypes.push(EVENT_TYPES.DEADLOCK,EVENT_TYPES.BLOCK);if(didRecover)eventTypes.push(EVENT_TYPES.RECOVERY);const newEvents=[];const numEvents=randomInt(1,3);for(let i=0;i<numEvents;i++){newEvents.push(generateEvent(prevCustomers,prevResources,randomPick(eventTypes)));}// Strategy-specific events for visible feedback\nconst ts=()=>new Date().toLocaleTimeString('en-US',{hour12:false})+'.'+String(new Date().getMilliseconds()).padStart(3,'0');if(preventionEnabled&&Math.random()>0.35){const c=randomPick(prevCustomers);const r=randomPick(prevResources);newEvents.push({id:Date.now()+Math.random(),timestamp:ts(),type:'prevention',label:'Prevention Active',color:'#10b981',message:\"Prevention: enforced resource ordering for \".concat(c.name,\" \\u2192 \").concat(r.name),customer:c.name,resource:r.name});}if(avoidanceEnabled&&Math.random()>0.35){const c=randomPick(prevCustomers);const r=randomPick(prevResources);const safe=Math.random()>0.3;newEvents.push({id:Date.now()+Math.random(),timestamp:ts(),type:safe?'avoidance_safe':'avoidance_denied',label:safe?\"Banker's Check Passed\":\"Banker's Check Denied\",color:safe?'#3b82f6':'#f59e0b',message:safe?\"Avoidance: safe state verified for \".concat(c.name,\" \\u2192 \").concat(r.name):\"Avoidance: denied unsafe request from \".concat(c.name,\" for \").concat(r.name),customer:c.name,resource:r.name});}setEventLog(prev=>[...newEvents,...prev].slice(0,MAX_LOG_ENTRIES));// Update metrics\nconst point=generatePerformancePoint(currentTick,stressTestActive);setPerfData(prev=>[...prev,point].slice(-MAX_PERF_POINTS));setTotalGranted(prev=>prev+point.granted);setTotalDenied(prev=>prev+point.denied);// Update graph\nsetGraphData(generateWaitForGraph(prevCustomers,prevResources));// Stress test data\nif(stressTestActive){setStressData(prev=>[...prev,generateStressData(currentTick,stressLevel)].slice(-MAX_STRESS_POINTS));}return prevResources;});return prevCustomers;});},[preventionEnabled,avoidanceEnabled,detectionEnabled,stressTestActive,stressLevel,activeResourceIds]);// Main simulation loop\nuseEffect(()=>{if(isRunning){intervalRef.current=setInterval(simulateTick,TICK_INTERVAL);}else{if(intervalRef.current)clearInterval(intervalRef.current);}return()=>{if(intervalRef.current)clearInterval(intervalRef.current);};},[isRunning,simulateTick]);// Mark / clear cycle edges in graph based on system status\nuseEffect(()=>{if(systemStatus==='deadlock'){setGraphData(prev=>{const edges=prev.edges.map(e=>_objectSpread({},e));const cycleEdges=edges.filter(e=>e.type==='waiting');if(cycleEdges.length>=2){cycleEdges.forEach(e=>{e.cycle=true;});}return _objectSpread(_objectSpread({},prev),{},{edges});});}else{// Clear all cycle flags and deadlocked node states when not in deadlock\nsetGraphData(prev=>{const hasAnyCycle=prev.edges.some(e=>e.cycle);const hasDeadlockedNode=prev.nodes.some(n=>n.state==='deadlocked');if(!hasAnyCycle&&!hasDeadlockedNode)return prev;const edges=prev.edges.map(e=>_objectSpread(_objectSpread({},e),{},{cycle:false}));const nodes=prev.nodes.map(n=>n.state==='deadlocked'?_objectSpread(_objectSpread({},n),{},{state:n.type==='customer'?'running':n.state}):n);return{nodes,edges};});}},[systemStatus]);const startSimulation=useCallback(()=>{setIsRunning(true);setSystemStatus('running');},[]);const stopSimulation=useCallback(()=>{setIsRunning(false);setSystemStatus('idle');},[]);const resetSystem=useCallback(()=>{setIsRunning(false);tickRef.current=0;setTick(0);setResources(generateInitialResources(8));setCustomers(generateInitialCustomers(6));setEventLog([]);setPerfData([]);setStressData([]);setGraphData({nodes:[],edges:[]});setSystemStatus('idle');setDeadlockCount(0);setRecoveryCount(0);setTotalGranted(0);setTotalDenied(0);setStressTestActive(false);setStressLevel(5);setActiveResourceIds(new Set());setPreventionEnabled(false);setAvoidanceEnabled(false);setDetectionEnabled(true);},[]);const toggleStressTest=useCallback(()=>{setStressTestActive(prev=>!prev);if(!stressTestActive){setStressData([]);// Increase customer count during stress\nsetCustomers(prev=>{if(prev.length<12){const extra=generateInitialCustomers(12).slice(prev.length);extra.forEach(c=>{c.state='running';});return[...prev,...extra];}return prev;});}},[stressTestActive]);const adjustStressLevel=useCallback(delta=>{setStressLevel(prev=>Math.max(1,Math.min(10,prev+delta)));},[]);const toggleResourceActive=useCallback(resourceId=>{setActiveResourceIds(prev=>{const next=new Set(prev);if(next.has(resourceId)){next.delete(resourceId);}else{next.add(resourceId);}return next;});},[]);const clearResourceFilter=useCallback(()=>{setActiveResourceIds(new Set());},[]);return{// State\nisRunning,tick,systemStatus,resources,customers,eventLog,perfData,stressData,graphData,deadlockCount,recoveryCount,totalGranted,totalDenied,stressTestActive,stressLevel,activeResourceIds,preventionEnabled,avoidanceEnabled,detectionEnabled,// Actions\nstartSimulation,stopSimulation,resetSystem,toggleStressTest,adjustStressLevel,toggleResourceActive,clearResourceFilter,setPreventionEnabled,setAvoidanceEnabled,setDetectionEnabled};}","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","generateInitialResources","generateInitialCustomers","generateEvent","generatePerformancePoint","generateWaitForGraph","generateStressData","randomPick","randomInt","EVENT_TYPES","TICK_INTERVAL","MAX_LOG_ENTRIES","MAX_PERF_POINTS","MAX_STRESS_POINTS","useSimulation","isRunning","setIsRunning","tick","setTick","tickRef","preventionEnabled","setPreventionEnabled","avoidanceEnabled","setAvoidanceEnabled","detectionEnabled","setDetectionEnabled","stressTestActive","setStressTestActive","stressLevel","setStressLevel","activeResourceIds","setActiveResourceIds","Set","resources","setResources","customers","setCustomers","eventLog","setEventLog","perfData","setPerfData","stressData","setStressData","graphData","setGraphData","nodes","edges","systemStatus","setSystemStatus","deadlockCount","setDeadlockCount","recoveryCount","setRecoveryCount","totalGranted","setTotalGranted","totalDenied","setTotalDenied","intervalRef","systemStatusRef","current","simulateTick","currentTick","prev","updated","map","c","_objectSpread","forEach","state","Math","random","prevResources","prevCustomers","res","r","waitingThreads","custs","holding","activeSet","isResActive","size","has","id","availableRes","filter","available","includes","maxHeldIdx","length","max","parseInt","replace","safeRes","target","owner","name","currentInstances","push","waiting","totalAvailableAfter","waitingCount","c2","unavailable","releaseId","released","find","prevStatus","newStatus","didDeadlock","didRecover","shouldDeadlock","slice","running","setTimeout","s","eventTypes","REQUEST","ALLOCATE","RELEASE","DEADLOCK","BLOCK","RECOVERY","newEvents","numEvents","i","ts","Date","toLocaleTimeString","hour12","String","getMilliseconds","padStart","now","timestamp","type","label","color","message","concat","customer","resource","safe","point","granted","denied","setInterval","clearInterval","e","cycleEdges","cycle","hasAnyCycle","some","hasDeadlockedNode","n","startSimulation","stopSimulation","resetSystem","toggleStressTest","extra","adjustStressLevel","delta","min","toggleResourceActive","resourceId","next","delete","add","clearResourceFilter"],"sources":["C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/src/hooks/useSimulation.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n  generateInitialResources,\r\n  generateInitialCustomers,\r\n  generateEvent,\r\n  generatePerformancePoint,\r\n  generateWaitForGraph,\r\n  generateStressData,\r\n  randomPick,\r\n  randomInt,\r\n  EVENT_TYPES,\r\n} from '../data/mockData';\r\n\r\nconst TICK_INTERVAL = 1200;\r\nconst MAX_LOG_ENTRIES = 200;\r\nconst MAX_PERF_POINTS = 60;\r\nconst MAX_STRESS_POINTS = 40;\r\n\r\nexport function useSimulation() {\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const [tick, setTick] = useState(0);\r\n  const tickRef = useRef(0);\r\n\r\n  // Strategy toggles\r\n  const [preventionEnabled, setPreventionEnabled] = useState(false);\r\n  const [avoidanceEnabled, setAvoidanceEnabled] = useState(false);\r\n  const [detectionEnabled, setDetectionEnabled] = useState(true);\r\n  const [stressTestActive, setStressTestActive] = useState(false);\r\n  const [stressLevel, setStressLevel] = useState(5); // 1-10 scale\r\n\r\n  // Active resource filter (empty Set = all active)\r\n  const [activeResourceIds, setActiveResourceIds] = useState(new Set());\r\n\r\n  // Core state\r\n  const [resources, setResources] = useState(() => generateInitialResources(8));\r\n  const [customers, setCustomers] = useState(() => generateInitialCustomers(6));\r\n  const [eventLog, setEventLog] = useState([]);\r\n  const [perfData, setPerfData] = useState([]);\r\n  const [stressData, setStressData] = useState([]);\r\n  const [graphData, setGraphData] = useState({ nodes: [], edges: [] });\r\n\r\n  // Aggregate metrics\r\n  const [systemStatus, setSystemStatus] = useState('idle'); // idle, running, deadlock, recovery\r\n  const [deadlockCount, setDeadlockCount] = useState(0);\r\n  const [recoveryCount, setRecoveryCount] = useState(0);\r\n  const [totalGranted, setTotalGranted] = useState(0);\r\n  const [totalDenied, setTotalDenied] = useState(0);\r\n\r\n  const intervalRef = useRef(null);\r\n  const systemStatusRef = useRef('idle');\r\n\r\n  // Keep ref in sync so simulateTick reads current status (avoids stale closure)\r\n  useEffect(() => {\r\n    systemStatusRef.current = systemStatus;\r\n  }, [systemStatus]);\r\n\r\n  const simulateTick = useCallback(() => {\r\n    tickRef.current += 1;\r\n    const currentTick = tickRef.current;\r\n    setTick(currentTick);\r\n\r\n    setCustomers((prev) => {\r\n      const updated = prev.map((c) => ({ ...c }));\r\n      updated.forEach((c) => {\r\n        if (c.state === 'idle' && Math.random() > 0.4) {\r\n          c.state = 'running';\r\n        }\r\n      });\r\n      return updated;\r\n    });\r\n\r\n    setResources((prevResources) => {\r\n      setCustomers((prevCustomers) => {\r\n        const res = prevResources.map((r) => ({ ...r, waitingThreads: [] }));\r\n        const custs = prevCustomers.map((c) => ({ ...c, holding: [...c.holding] }));\r\n\r\n        // Determine which resources are active (empty set = all)\r\n        const activeSet = activeResourceIds;\r\n        const isResActive = (r) => activeSet.size === 0 || activeSet.has(r.id);\r\n\r\n        // Simulate resource allocation\r\n        custs.forEach((c) => {\r\n          if (c.state === 'running' || c.state === 'waiting') {\r\n            const availableRes = res.filter(\r\n              (r) => isResActive(r) && r.available && !c.holding.includes(r.id)\r\n            );\r\n\r\n            if (preventionEnabled) {\r\n              // PREVENTION: enforce resource ordering — only acquire resources with ID > max held\r\n              const maxHeldIdx = c.holding.length > 0\r\n                ? Math.max(...c.holding.map((id) => parseInt(id.replace('R', ''))))\r\n                : -1;\r\n              const safeRes = availableRes.filter(\r\n                (r) => parseInt(r.id.replace('R', '')) > maxHeldIdx\r\n              );\r\n              if (safeRes.length > 0 && Math.random() > 0.25) {\r\n                const target = randomPick(safeRes);\r\n                target.available = false;\r\n                target.owner = c.name;\r\n                target.currentInstances += 1;\r\n                c.holding.push(target.id);\r\n                c.waiting = null;\r\n                c.state = 'running';\r\n              } else if (c.holding.length === 0 && availableRes.length > 0 && Math.random() > 0.3) {\r\n                const target = randomPick(availableRes);\r\n                target.available = false;\r\n                target.owner = c.name;\r\n                target.currentInstances += 1;\r\n                c.holding.push(target.id);\r\n                c.waiting = null;\r\n                c.state = 'running';\r\n              }\r\n              // Prevention: never enter circular wait\r\n\r\n            } else if (avoidanceEnabled) {\r\n              // AVOIDANCE: simplified Banker's check — deny if granting leaves system unsafe\r\n              if (availableRes.length > 0 && Math.random() > 0.3) {\r\n                const target = randomPick(availableRes);\r\n                const totalAvailableAfter = res.filter((r) => r.available).length - 1;\r\n                const waitingCount = custs.filter((c2) => c2.state === 'waiting').length;\r\n                if (totalAvailableAfter >= waitingCount || waitingCount === 0) {\r\n                  target.available = false;\r\n                  target.owner = c.name;\r\n                  target.currentInstances += 1;\r\n                  c.holding.push(target.id);\r\n                  c.waiting = null;\r\n                  c.state = 'running';\r\n                }\r\n              } else if (Math.random() > 0.5) {\r\n                const unavailable = res.filter(\r\n                  (r) => isResActive(r) && !r.available && !c.holding.includes(r.id)\r\n                );\r\n                if (unavailable.length > 0) {\r\n                  const target = randomPick(unavailable);\r\n                  target.waitingThreads.push(c.name);\r\n                  c.waiting = target.id;\r\n                  c.state = 'waiting';\r\n                }\r\n              }\r\n\r\n            } else {\r\n              // NO STRATEGY: normal allocation (can cause deadlocks)\r\n              if (availableRes.length > 0 && Math.random() > 0.3) {\r\n                const target = randomPick(availableRes);\r\n                target.available = false;\r\n                target.owner = c.name;\r\n                target.currentInstances += 1;\r\n                c.holding.push(target.id);\r\n                c.waiting = null;\r\n                c.state = 'running';\r\n              } else if (Math.random() > 0.5) {\r\n                const unavailable = res.filter(\r\n                  (r) => isResActive(r) && !r.available && !c.holding.includes(r.id)\r\n                );\r\n                if (unavailable.length > 0) {\r\n                  const target = randomPick(unavailable);\r\n                  target.waitingThreads.push(c.name);\r\n                  c.waiting = target.id;\r\n                  c.state = 'waiting';\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Randomly release resources\r\n          if (c.holding.length > 0 && Math.random() > 0.65) {\r\n            const releaseId = randomPick(c.holding);\r\n            c.holding = c.holding.filter((id) => id !== releaseId);\r\n            const released = res.find((r) => r.id === releaseId);\r\n            if (released) {\r\n              released.available = true;\r\n              released.owner = null;\r\n              released.currentInstances = Math.max(0, released.currentInstances - 1);\r\n            }\r\n            if (c.holding.length === 0 && !c.waiting) {\r\n              c.state = Math.random() > 0.3 ? 'running' : 'idle';\r\n            }\r\n          }\r\n        });\r\n\r\n        setResources(res);\r\n        return custs;\r\n      });\r\n      return prevResources;\r\n    });\r\n\r\n    // ---- Deadlock State Machine (uses ref to avoid stale closure) ----\r\n    const prevStatus = systemStatusRef.current;\r\n    let newStatus = prevStatus;\r\n    let didDeadlock = false;\r\n    let didRecover = false;\r\n\r\n    if (preventionEnabled || avoidanceEnabled) {\r\n      // Strategies active → no deadlocks possible; clear any leftover deadlocked state\r\n      setCustomers((prev) =>\r\n        prev.map((c) =>\r\n          c.state === 'deadlocked' ? { ...c, state: 'running', waiting: null } : c\r\n        )\r\n      );\r\n      newStatus = currentTick > 1 ? 'running' : prevStatus;\r\n    } else {\r\n      // No strategies → deadlocks can occur\r\n      const shouldDeadlock = Math.random() > 0.82;\r\n\r\n      if (shouldDeadlock && prevStatus !== 'deadlock') {\r\n        didDeadlock = true;\r\n        setDeadlockCount((prev) => prev + 1);\r\n        newStatus = 'deadlock';\r\n        setCustomers((prev) => {\r\n          const updated = prev.map((c) => ({ ...c }));\r\n          const waiting = updated.filter((c) => c.state === 'waiting');\r\n          if (waiting.length >= 2) {\r\n            waiting.slice(0, 2).forEach((c) => { c.state = 'deadlocked'; });\r\n          } else {\r\n            const running = updated.filter((c) => c.state === 'running');\r\n            running.slice(0, 2).forEach((c) => { c.state = 'deadlocked'; });\r\n          }\r\n          return updated;\r\n        });\r\n      } else if (prevStatus === 'deadlock') {\r\n        if (detectionEnabled) {\r\n          didRecover = true;\r\n          setRecoveryCount((prev) => prev + 1);\r\n          newStatus = 'recovery';\r\n          // Clear deadlocked customers and release their resources\r\n          setCustomers((prev) =>\r\n            prev.map((c) =>\r\n              c.state === 'deadlocked'\r\n                ? { ...c, state: 'running', waiting: null, holding: [] }\r\n                : c\r\n            )\r\n          );\r\n          setResources((prev) =>\r\n            prev.map((r) => ({\r\n              ...r,\r\n              available: true,\r\n              owner: null,\r\n              currentInstances: 0,\r\n              waitingThreads: [],\r\n            }))\r\n          );\r\n          setTimeout(() => {\r\n            setSystemStatus((s) => (s === 'recovery' ? 'running' : s));\r\n          }, 2500);\r\n        } else {\r\n          newStatus = 'deadlock'; // Stuck — no detection to recover\r\n        }\r\n      } else if (prevStatus === 'recovery') {\r\n        newStatus = 'recovery'; // Let timeout handle transition\r\n      } else {\r\n        newStatus = currentTick > 1 ? 'running' : prevStatus;\r\n      }\r\n    }\r\n\r\n    setSystemStatus(newStatus);\r\n\r\n    // Generate events\r\n    setCustomers((prevCustomers) => {\r\n      setResources((prevResources) => {\r\n        const eventTypes = [EVENT_TYPES.REQUEST, EVENT_TYPES.ALLOCATE, EVENT_TYPES.RELEASE];\r\n        if (didDeadlock) eventTypes.push(EVENT_TYPES.DEADLOCK, EVENT_TYPES.BLOCK);\r\n        if (didRecover) eventTypes.push(EVENT_TYPES.RECOVERY);\r\n\r\n        const newEvents = [];\r\n        const numEvents = randomInt(1, 3);\r\n        for (let i = 0; i < numEvents; i++) {\r\n          newEvents.push(generateEvent(prevCustomers, prevResources, randomPick(eventTypes)));\r\n        }\r\n\r\n        // Strategy-specific events for visible feedback\r\n        const ts = () =>\r\n          new Date().toLocaleTimeString('en-US', { hour12: false }) +\r\n          '.' +\r\n          String(new Date().getMilliseconds()).padStart(3, '0');\r\n\r\n        if (preventionEnabled && Math.random() > 0.35) {\r\n          const c = randomPick(prevCustomers);\r\n          const r = randomPick(prevResources);\r\n          newEvents.push({\r\n            id: Date.now() + Math.random(),\r\n            timestamp: ts(),\r\n            type: 'prevention',\r\n            label: 'Prevention Active',\r\n            color: '#10b981',\r\n            message: `Prevention: enforced resource ordering for ${c.name} → ${r.name}`,\r\n            customer: c.name,\r\n            resource: r.name,\r\n          });\r\n        }\r\n\r\n        if (avoidanceEnabled && Math.random() > 0.35) {\r\n          const c = randomPick(prevCustomers);\r\n          const r = randomPick(prevResources);\r\n          const safe = Math.random() > 0.3;\r\n          newEvents.push({\r\n            id: Date.now() + Math.random(),\r\n            timestamp: ts(),\r\n            type: safe ? 'avoidance_safe' : 'avoidance_denied',\r\n            label: safe ? \"Banker's Check Passed\" : \"Banker's Check Denied\",\r\n            color: safe ? '#3b82f6' : '#f59e0b',\r\n            message: safe\r\n              ? `Avoidance: safe state verified for ${c.name} → ${r.name}`\r\n              : `Avoidance: denied unsafe request from ${c.name} for ${r.name}`,\r\n            customer: c.name,\r\n            resource: r.name,\r\n          });\r\n        }\r\n\r\n        setEventLog((prev) => [...newEvents, ...prev].slice(0, MAX_LOG_ENTRIES));\r\n\r\n        // Update metrics\r\n        const point = generatePerformancePoint(currentTick, stressTestActive);\r\n        setPerfData((prev) => [...prev, point].slice(-MAX_PERF_POINTS));\r\n        setTotalGranted((prev) => prev + point.granted);\r\n        setTotalDenied((prev) => prev + point.denied);\r\n\r\n        // Update graph\r\n        setGraphData(generateWaitForGraph(prevCustomers, prevResources));\r\n\r\n        // Stress test data\r\n        if (stressTestActive) {\r\n          setStressData((prev) =>\r\n            [...prev, generateStressData(currentTick, stressLevel)].slice(-MAX_STRESS_POINTS)\r\n          );\r\n        }\r\n\r\n        return prevResources;\r\n      });\r\n      return prevCustomers;\r\n    });\r\n  }, [preventionEnabled, avoidanceEnabled, detectionEnabled, stressTestActive, stressLevel, activeResourceIds]);\r\n\r\n  // Main simulation loop\r\n  useEffect(() => {\r\n    if (isRunning) {\r\n      intervalRef.current = setInterval(simulateTick, TICK_INTERVAL);\r\n    } else {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    }\r\n    return () => {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    };\r\n  }, [isRunning, simulateTick]);\r\n\r\n  // Mark / clear cycle edges in graph based on system status\r\n  useEffect(() => {\r\n    if (systemStatus === 'deadlock') {\r\n      setGraphData((prev) => {\r\n        const edges = prev.edges.map((e) => ({ ...e }));\r\n        const cycleEdges = edges.filter((e) => e.type === 'waiting');\r\n        if (cycleEdges.length >= 2) {\r\n          cycleEdges.forEach((e) => { e.cycle = true; });\r\n        }\r\n        return { ...prev, edges };\r\n      });\r\n    } else {\r\n      // Clear all cycle flags and deadlocked node states when not in deadlock\r\n      setGraphData((prev) => {\r\n        const hasAnyCycle = prev.edges.some((e) => e.cycle);\r\n        const hasDeadlockedNode = prev.nodes.some((n) => n.state === 'deadlocked');\r\n        if (!hasAnyCycle && !hasDeadlockedNode) return prev;\r\n        const edges = prev.edges.map((e) => ({ ...e, cycle: false }));\r\n        const nodes = prev.nodes.map((n) =>\r\n          n.state === 'deadlocked' ? { ...n, state: n.type === 'customer' ? 'running' : n.state } : n\r\n        );\r\n        return { nodes, edges };\r\n      });\r\n    }\r\n  }, [systemStatus]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsRunning(true);\r\n    setSystemStatus('running');\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsRunning(false);\r\n    setSystemStatus('idle');\r\n  }, []);\r\n\r\n  const resetSystem = useCallback(() => {\r\n    setIsRunning(false);\r\n    tickRef.current = 0;\r\n    setTick(0);\r\n    setResources(generateInitialResources(8));\r\n    setCustomers(generateInitialCustomers(6));\r\n    setEventLog([]);\r\n    setPerfData([]);\r\n    setStressData([]);\r\n    setGraphData({ nodes: [], edges: [] });\r\n    setSystemStatus('idle');\r\n    setDeadlockCount(0);\r\n    setRecoveryCount(0);\r\n    setTotalGranted(0);\r\n    setTotalDenied(0);\r\n    setStressTestActive(false);\r\n    setStressLevel(5);\r\n    setActiveResourceIds(new Set());\r\n    setPreventionEnabled(false);\r\n    setAvoidanceEnabled(false);\r\n    setDetectionEnabled(true);\r\n  }, []);\r\n\r\n  const toggleStressTest = useCallback(() => {\r\n    setStressTestActive((prev) => !prev);\r\n    if (!stressTestActive) {\r\n      setStressData([]);\r\n      // Increase customer count during stress\r\n      setCustomers((prev) => {\r\n        if (prev.length < 12) {\r\n          const extra = generateInitialCustomers(12).slice(prev.length);\r\n          extra.forEach((c) => { c.state = 'running'; });\r\n          return [...prev, ...extra];\r\n        }\r\n        return prev;\r\n      });\r\n    }\r\n  }, [stressTestActive]);\r\n\r\n  const adjustStressLevel = useCallback((delta) => {\r\n    setStressLevel((prev) => Math.max(1, Math.min(10, prev + delta)));\r\n  }, []);\r\n\r\n  const toggleResourceActive = useCallback((resourceId) => {\r\n    setActiveResourceIds((prev) => {\r\n      const next = new Set(prev);\r\n      if (next.has(resourceId)) {\r\n        next.delete(resourceId);\r\n      } else {\r\n        next.add(resourceId);\r\n      }\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const clearResourceFilter = useCallback(() => {\r\n    setActiveResourceIds(new Set());\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    isRunning,\r\n    tick,\r\n    systemStatus,\r\n    resources,\r\n    customers,\r\n    eventLog,\r\n    perfData,\r\n    stressData,\r\n    graphData,\r\n    deadlockCount,\r\n    recoveryCount,\r\n    totalGranted,\r\n    totalDenied,\r\n    stressTestActive,\r\n    stressLevel,\r\n    activeResourceIds,\r\n    preventionEnabled,\r\n    avoidanceEnabled,\r\n    detectionEnabled,\r\n\r\n    // Actions\r\n    startSimulation,\r\n    stopSimulation,\r\n    resetSystem,\r\n    toggleStressTest,\r\n    adjustStressLevel,\r\n    toggleResourceActive,\r\n    clearResourceFilter,\r\n    setPreventionEnabled,\r\n    setAvoidanceEnabled,\r\n    setDetectionEnabled,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}