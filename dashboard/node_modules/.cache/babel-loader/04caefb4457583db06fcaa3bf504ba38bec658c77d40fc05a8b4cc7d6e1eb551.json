{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { generateInitialResources, generateInitialCustomers, generateEvent, generatePerformancePoint, generateWaitForGraph, generateStressData, randomPick, randomInt, EVENT_TYPES } from '../data/mockData';\nconst TICK_INTERVAL = 1200;\nconst MAX_LOG_ENTRIES = 200;\nconst MAX_PERF_POINTS = 60;\nconst MAX_STRESS_POINTS = 40;\nexport function useSimulation() {\n  _s();\n  const [isRunning, setIsRunning] = useState(false);\n  const [tick, setTick] = useState(0);\n  const tickRef = useRef(0);\n\n  // Strategy toggles\n  const [preventionEnabled, setPreventionEnabled] = useState(false);\n  const [avoidanceEnabled, setAvoidanceEnabled] = useState(false);\n  const [detectionEnabled, setDetectionEnabled] = useState(true);\n  const [stressTestActive, setStressTestActive] = useState(false);\n\n  // Core state\n  const [resources, setResources] = useState(() => generateInitialResources(8));\n  const [customers, setCustomers] = useState(() => generateInitialCustomers(6));\n  const [eventLog, setEventLog] = useState([]);\n  const [perfData, setPerfData] = useState([]);\n  const [stressData, setStressData] = useState([]);\n  const [graphData, setGraphData] = useState({\n    nodes: [],\n    edges: []\n  });\n\n  // Aggregate metrics\n  const [systemStatus, setSystemStatus] = useState('idle'); // idle, running, deadlock, recovery\n  const [deadlockCount, setDeadlockCount] = useState(0);\n  const [recoveryCount, setRecoveryCount] = useState(0);\n  const [totalGranted, setTotalGranted] = useState(0);\n  const [totalDenied, setTotalDenied] = useState(0);\n  const intervalRef = useRef(null);\n  const simulateTick = useCallback(() => {\n    tickRef.current += 1;\n    const currentTick = tickRef.current;\n    setTick(currentTick);\n    setCustomers(prev => {\n      const updated = prev.map(c => ({\n        ...c\n      }));\n      updated.forEach(c => {\n        if (c.state === 'idle' && Math.random() > 0.4) {\n          c.state = 'running';\n        }\n      });\n      return updated;\n    });\n    setResources(prevResources => {\n      setCustomers(prevCustomers => {\n        const res = prevResources.map(r => ({\n          ...r,\n          waitingThreads: []\n        }));\n        const custs = prevCustomers.map(c => ({\n          ...c,\n          holding: [...c.holding]\n        }));\n\n        // Simulate resource allocation\n        custs.forEach(c => {\n          if (c.state === 'running' || c.state === 'waiting') {\n            const availableRes = res.filter(r => r.available && !c.holding.includes(r.id));\n            if (availableRes.length > 0 && Math.random() > 0.3) {\n              const target = randomPick(availableRes);\n              target.available = false;\n              target.owner = c.name;\n              target.currentInstances += 1;\n              c.holding.push(target.id);\n              c.waiting = null;\n              c.state = 'running';\n            } else if (Math.random() > 0.5) {\n              const unavailable = res.filter(r => !r.available && !c.holding.includes(r.id));\n              if (unavailable.length > 0) {\n                const target = randomPick(unavailable);\n                target.waitingThreads.push(c.name);\n                c.waiting = target.id;\n                c.state = 'waiting';\n              }\n            }\n          }\n\n          // Randomly release resources\n          if (c.holding.length > 0 && Math.random() > 0.65) {\n            const releaseId = randomPick(c.holding);\n            c.holding = c.holding.filter(id => id !== releaseId);\n            const released = res.find(r => r.id === releaseId);\n            if (released) {\n              released.available = true;\n              released.owner = null;\n              released.currentInstances = Math.max(0, released.currentInstances - 1);\n            }\n            if (c.holding.length === 0 && !c.waiting) {\n              c.state = Math.random() > 0.3 ? 'running' : 'idle';\n            }\n          }\n        });\n        setResources(res);\n        return custs;\n      });\n      return prevResources;\n    });\n\n    // Determine deadlock occurrence\n    const shouldDeadlock = !preventionEnabled && !avoidanceEnabled && Math.random() > 0.82;\n    const isRecovering = shouldDeadlock && detectionEnabled && Math.random() > 0.3;\n    if (shouldDeadlock) {\n      setDeadlockCount(prev => prev + 1);\n      setSystemStatus('deadlock');\n\n      // Mark some customers as deadlocked\n      setCustomers(prev => {\n        const updated = prev.map(c => ({\n          ...c\n        }));\n        const waiting = updated.filter(c => c.state === 'waiting');\n        if (waiting.length >= 2) {\n          waiting.slice(0, 2).forEach(c => {\n            c.state = 'deadlocked';\n          });\n        }\n        return updated;\n      });\n    } else if (isRecovering) {\n      setRecoveryCount(prev => prev + 1);\n      setSystemStatus('recovery');\n      setTimeout(() => setSystemStatus('running'), 2000);\n      setCustomers(prev => prev.map(c => c.state === 'deadlocked' ? {\n        ...c,\n        state: 'running',\n        waiting: null\n      } : c));\n    } else {\n      setSystemStatus(prev => prev === 'deadlock' || prev === 'recovery' ? 'running' : prev);\n      if (currentTick > 1) setSystemStatus('running');\n    }\n\n    // Generate events\n    setCustomers(prevCustomers => {\n      setResources(prevResources => {\n        const eventTypes = [EVENT_TYPES.REQUEST, EVENT_TYPES.ALLOCATE, EVENT_TYPES.RELEASE];\n        if (shouldDeadlock) eventTypes.push(EVENT_TYPES.DEADLOCK, EVENT_TYPES.BLOCK);\n        if (isRecovering) eventTypes.push(EVENT_TYPES.RECOVERY);\n        const newEvents = [];\n        const numEvents = randomInt(1, 3);\n        for (let i = 0; i < numEvents; i++) {\n          newEvents.push(generateEvent(prevCustomers, prevResources, randomPick(eventTypes)));\n        }\n        setEventLog(prev => [...newEvents, ...prev].slice(0, MAX_LOG_ENTRIES));\n\n        // Update metrics\n        const point = generatePerformancePoint(currentTick, stressTestActive);\n        setPerfData(prev => [...prev, point].slice(-MAX_PERF_POINTS));\n        setTotalGranted(prev => prev + point.granted);\n        setTotalDenied(prev => prev + point.denied);\n\n        // Update graph\n        setGraphData(generateWaitForGraph(prevCustomers, prevResources));\n\n        // Stress test data\n        if (stressTestActive) {\n          setStressData(prev => [...prev, generateStressData(currentTick)].slice(-MAX_STRESS_POINTS));\n        }\n        return prevResources;\n      });\n      return prevCustomers;\n    });\n  }, [preventionEnabled, avoidanceEnabled, detectionEnabled, stressTestActive]);\n\n  // Main simulation loop\n  useEffect(() => {\n    if (isRunning) {\n      intervalRef.current = setInterval(simulateTick, TICK_INTERVAL);\n    } else {\n      if (intervalRef.current) clearInterval(intervalRef.current);\n    }\n    return () => {\n      if (intervalRef.current) clearInterval(intervalRef.current);\n    };\n  }, [isRunning, simulateTick]);\n\n  // Mark cycle edges in graph when deadlock\n  useEffect(() => {\n    if (systemStatus === 'deadlock') {\n      setGraphData(prev => {\n        const edges = prev.edges.map(e => ({\n          ...e\n        }));\n        // Mark waiting edges as cycle\n        const cycleEdges = edges.filter(e => e.type === 'waiting');\n        if (cycleEdges.length >= 2) {\n          cycleEdges.forEach(e => {\n            e.cycle = true;\n          });\n        }\n        return {\n          ...prev,\n          edges\n        };\n      });\n    }\n  }, [systemStatus]);\n  const startSimulation = useCallback(() => {\n    setIsRunning(true);\n    setSystemStatus('running');\n  }, []);\n  const stopSimulation = useCallback(() => {\n    setIsRunning(false);\n    setSystemStatus('idle');\n  }, []);\n  const resetSystem = useCallback(() => {\n    setIsRunning(false);\n    tickRef.current = 0;\n    setTick(0);\n    setResources(generateInitialResources(8));\n    setCustomers(generateInitialCustomers(6));\n    setEventLog([]);\n    setPerfData([]);\n    setStressData([]);\n    setGraphData({\n      nodes: [],\n      edges: []\n    });\n    setSystemStatus('idle');\n    setDeadlockCount(0);\n    setRecoveryCount(0);\n    setTotalGranted(0);\n    setTotalDenied(0);\n    setStressTestActive(false);\n    setPreventionEnabled(false);\n    setAvoidanceEnabled(false);\n    setDetectionEnabled(true);\n  }, []);\n  const toggleStressTest = useCallback(() => {\n    setStressTestActive(prev => !prev);\n    if (!stressTestActive) {\n      setStressData([]);\n      // Increase customer count during stress\n      setCustomers(prev => {\n        if (prev.length < 12) {\n          const extra = generateInitialCustomers(12).slice(prev.length);\n          extra.forEach(c => {\n            c.state = 'running';\n          });\n          return [...prev, ...extra];\n        }\n        return prev;\n      });\n    }\n  }, [stressTestActive]);\n  return {\n    // State\n    isRunning,\n    tick,\n    systemStatus,\n    resources,\n    customers,\n    eventLog,\n    perfData,\n    stressData,\n    graphData,\n    deadlockCount,\n    recoveryCount,\n    totalGranted,\n    totalDenied,\n    stressTestActive,\n    preventionEnabled,\n    avoidanceEnabled,\n    detectionEnabled,\n    // Actions\n    startSimulation,\n    stopSimulation,\n    resetSystem,\n    toggleStressTest,\n    setPreventionEnabled,\n    setAvoidanceEnabled,\n    setDetectionEnabled\n  };\n}\n_s(useSimulation, \"ALhOQYQqT9CvSp8JU8Wrb2bqgzE=\");","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","generateInitialResources","generateInitialCustomers","generateEvent","generatePerformancePoint","generateWaitForGraph","generateStressData","randomPick","randomInt","EVENT_TYPES","TICK_INTERVAL","MAX_LOG_ENTRIES","MAX_PERF_POINTS","MAX_STRESS_POINTS","useSimulation","_s","isRunning","setIsRunning","tick","setTick","tickRef","preventionEnabled","setPreventionEnabled","avoidanceEnabled","setAvoidanceEnabled","detectionEnabled","setDetectionEnabled","stressTestActive","setStressTestActive","resources","setResources","customers","setCustomers","eventLog","setEventLog","perfData","setPerfData","stressData","setStressData","graphData","setGraphData","nodes","edges","systemStatus","setSystemStatus","deadlockCount","setDeadlockCount","recoveryCount","setRecoveryCount","totalGranted","setTotalGranted","totalDenied","setTotalDenied","intervalRef","simulateTick","current","currentTick","prev","updated","map","c","forEach","state","Math","random","prevResources","prevCustomers","res","r","waitingThreads","custs","holding","availableRes","filter","available","includes","id","length","target","owner","name","currentInstances","push","waiting","unavailable","releaseId","released","find","max","shouldDeadlock","isRecovering","slice","setTimeout","eventTypes","REQUEST","ALLOCATE","RELEASE","DEADLOCK","BLOCK","RECOVERY","newEvents","numEvents","i","point","granted","denied","setInterval","clearInterval","e","cycleEdges","type","cycle","startSimulation","stopSimulation","resetSystem","toggleStressTest","extra"],"sources":["C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/src/hooks/useSimulation.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n  generateInitialResources,\r\n  generateInitialCustomers,\r\n  generateEvent,\r\n  generatePerformancePoint,\r\n  generateWaitForGraph,\r\n  generateStressData,\r\n  randomPick,\r\n  randomInt,\r\n  EVENT_TYPES,\r\n} from '../data/mockData';\r\n\r\nconst TICK_INTERVAL = 1200;\r\nconst MAX_LOG_ENTRIES = 200;\r\nconst MAX_PERF_POINTS = 60;\r\nconst MAX_STRESS_POINTS = 40;\r\n\r\nexport function useSimulation() {\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const [tick, setTick] = useState(0);\r\n  const tickRef = useRef(0);\r\n\r\n  // Strategy toggles\r\n  const [preventionEnabled, setPreventionEnabled] = useState(false);\r\n  const [avoidanceEnabled, setAvoidanceEnabled] = useState(false);\r\n  const [detectionEnabled, setDetectionEnabled] = useState(true);\r\n  const [stressTestActive, setStressTestActive] = useState(false);\r\n\r\n  // Core state\r\n  const [resources, setResources] = useState(() => generateInitialResources(8));\r\n  const [customers, setCustomers] = useState(() => generateInitialCustomers(6));\r\n  const [eventLog, setEventLog] = useState([]);\r\n  const [perfData, setPerfData] = useState([]);\r\n  const [stressData, setStressData] = useState([]);\r\n  const [graphData, setGraphData] = useState({ nodes: [], edges: [] });\r\n\r\n  // Aggregate metrics\r\n  const [systemStatus, setSystemStatus] = useState('idle'); // idle, running, deadlock, recovery\r\n  const [deadlockCount, setDeadlockCount] = useState(0);\r\n  const [recoveryCount, setRecoveryCount] = useState(0);\r\n  const [totalGranted, setTotalGranted] = useState(0);\r\n  const [totalDenied, setTotalDenied] = useState(0);\r\n\r\n  const intervalRef = useRef(null);\r\n\r\n  const simulateTick = useCallback(() => {\r\n    tickRef.current += 1;\r\n    const currentTick = tickRef.current;\r\n    setTick(currentTick);\r\n\r\n    setCustomers((prev) => {\r\n      const updated = prev.map((c) => ({ ...c }));\r\n      updated.forEach((c) => {\r\n        if (c.state === 'idle' && Math.random() > 0.4) {\r\n          c.state = 'running';\r\n        }\r\n      });\r\n      return updated;\r\n    });\r\n\r\n    setResources((prevResources) => {\r\n      setCustomers((prevCustomers) => {\r\n        const res = prevResources.map((r) => ({ ...r, waitingThreads: [] }));\r\n        const custs = prevCustomers.map((c) => ({ ...c, holding: [...c.holding] }));\r\n\r\n        // Simulate resource allocation\r\n        custs.forEach((c) => {\r\n          if (c.state === 'running' || c.state === 'waiting') {\r\n            const availableRes = res.filter(\r\n              (r) => r.available && !c.holding.includes(r.id)\r\n            );\r\n            if (availableRes.length > 0 && Math.random() > 0.3) {\r\n              const target = randomPick(availableRes);\r\n              target.available = false;\r\n              target.owner = c.name;\r\n              target.currentInstances += 1;\r\n              c.holding.push(target.id);\r\n              c.waiting = null;\r\n              c.state = 'running';\r\n            } else if (Math.random() > 0.5) {\r\n              const unavailable = res.filter(\r\n                (r) => !r.available && !c.holding.includes(r.id)\r\n              );\r\n              if (unavailable.length > 0) {\r\n                const target = randomPick(unavailable);\r\n                target.waitingThreads.push(c.name);\r\n                c.waiting = target.id;\r\n                c.state = 'waiting';\r\n              }\r\n            }\r\n          }\r\n\r\n          // Randomly release resources\r\n          if (c.holding.length > 0 && Math.random() > 0.65) {\r\n            const releaseId = randomPick(c.holding);\r\n            c.holding = c.holding.filter((id) => id !== releaseId);\r\n            const released = res.find((r) => r.id === releaseId);\r\n            if (released) {\r\n              released.available = true;\r\n              released.owner = null;\r\n              released.currentInstances = Math.max(0, released.currentInstances - 1);\r\n            }\r\n            if (c.holding.length === 0 && !c.waiting) {\r\n              c.state = Math.random() > 0.3 ? 'running' : 'idle';\r\n            }\r\n          }\r\n        });\r\n\r\n        setResources(res);\r\n        return custs;\r\n      });\r\n      return prevResources;\r\n    });\r\n\r\n    // Determine deadlock occurrence\r\n    const shouldDeadlock = !preventionEnabled && !avoidanceEnabled && Math.random() > 0.82;\r\n    const isRecovering = shouldDeadlock && detectionEnabled && Math.random() > 0.3;\r\n\r\n    if (shouldDeadlock) {\r\n      setDeadlockCount((prev) => prev + 1);\r\n      setSystemStatus('deadlock');\r\n\r\n      // Mark some customers as deadlocked\r\n      setCustomers((prev) => {\r\n        const updated = prev.map((c) => ({ ...c }));\r\n        const waiting = updated.filter((c) => c.state === 'waiting');\r\n        if (waiting.length >= 2) {\r\n          waiting.slice(0, 2).forEach((c) => {\r\n            c.state = 'deadlocked';\r\n          });\r\n        }\r\n        return updated;\r\n      });\r\n    } else if (isRecovering) {\r\n      setRecoveryCount((prev) => prev + 1);\r\n      setSystemStatus('recovery');\r\n      setTimeout(() => setSystemStatus('running'), 2000);\r\n\r\n      setCustomers((prev) =>\r\n        prev.map((c) => (c.state === 'deadlocked' ? { ...c, state: 'running', waiting: null } : c))\r\n      );\r\n    } else {\r\n      setSystemStatus((prev) => (prev === 'deadlock' || prev === 'recovery' ? 'running' : prev));\r\n      if (currentTick > 1) setSystemStatus('running');\r\n    }\r\n\r\n    // Generate events\r\n    setCustomers((prevCustomers) => {\r\n      setResources((prevResources) => {\r\n        const eventTypes = [EVENT_TYPES.REQUEST, EVENT_TYPES.ALLOCATE, EVENT_TYPES.RELEASE];\r\n        if (shouldDeadlock) eventTypes.push(EVENT_TYPES.DEADLOCK, EVENT_TYPES.BLOCK);\r\n        if (isRecovering) eventTypes.push(EVENT_TYPES.RECOVERY);\r\n\r\n        const newEvents = [];\r\n        const numEvents = randomInt(1, 3);\r\n        for (let i = 0; i < numEvents; i++) {\r\n          newEvents.push(generateEvent(prevCustomers, prevResources, randomPick(eventTypes)));\r\n        }\r\n\r\n        setEventLog((prev) => [...newEvents, ...prev].slice(0, MAX_LOG_ENTRIES));\r\n\r\n        // Update metrics\r\n        const point = generatePerformancePoint(currentTick, stressTestActive);\r\n        setPerfData((prev) => [...prev, point].slice(-MAX_PERF_POINTS));\r\n        setTotalGranted((prev) => prev + point.granted);\r\n        setTotalDenied((prev) => prev + point.denied);\r\n\r\n        // Update graph\r\n        setGraphData(generateWaitForGraph(prevCustomers, prevResources));\r\n\r\n        // Stress test data\r\n        if (stressTestActive) {\r\n          setStressData((prev) => [...prev, generateStressData(currentTick)].slice(-MAX_STRESS_POINTS));\r\n        }\r\n\r\n        return prevResources;\r\n      });\r\n      return prevCustomers;\r\n    });\r\n  }, [preventionEnabled, avoidanceEnabled, detectionEnabled, stressTestActive]);\r\n\r\n  // Main simulation loop\r\n  useEffect(() => {\r\n    if (isRunning) {\r\n      intervalRef.current = setInterval(simulateTick, TICK_INTERVAL);\r\n    } else {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    }\r\n    return () => {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    };\r\n  }, [isRunning, simulateTick]);\r\n\r\n  // Mark cycle edges in graph when deadlock\r\n  useEffect(() => {\r\n    if (systemStatus === 'deadlock') {\r\n      setGraphData((prev) => {\r\n        const edges = prev.edges.map((e) => ({ ...e }));\r\n        // Mark waiting edges as cycle\r\n        const cycleEdges = edges.filter((e) => e.type === 'waiting');\r\n        if (cycleEdges.length >= 2) {\r\n          cycleEdges.forEach((e) => {\r\n            e.cycle = true;\r\n          });\r\n        }\r\n        return { ...prev, edges };\r\n      });\r\n    }\r\n  }, [systemStatus]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsRunning(true);\r\n    setSystemStatus('running');\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsRunning(false);\r\n    setSystemStatus('idle');\r\n  }, []);\r\n\r\n  const resetSystem = useCallback(() => {\r\n    setIsRunning(false);\r\n    tickRef.current = 0;\r\n    setTick(0);\r\n    setResources(generateInitialResources(8));\r\n    setCustomers(generateInitialCustomers(6));\r\n    setEventLog([]);\r\n    setPerfData([]);\r\n    setStressData([]);\r\n    setGraphData({ nodes: [], edges: [] });\r\n    setSystemStatus('idle');\r\n    setDeadlockCount(0);\r\n    setRecoveryCount(0);\r\n    setTotalGranted(0);\r\n    setTotalDenied(0);\r\n    setStressTestActive(false);\r\n    setPreventionEnabled(false);\r\n    setAvoidanceEnabled(false);\r\n    setDetectionEnabled(true);\r\n  }, []);\r\n\r\n  const toggleStressTest = useCallback(() => {\r\n    setStressTestActive((prev) => !prev);\r\n    if (!stressTestActive) {\r\n      setStressData([]);\r\n      // Increase customer count during stress\r\n      setCustomers((prev) => {\r\n        if (prev.length < 12) {\r\n          const extra = generateInitialCustomers(12).slice(prev.length);\r\n          extra.forEach((c) => { c.state = 'running'; });\r\n          return [...prev, ...extra];\r\n        }\r\n        return prev;\r\n      });\r\n    }\r\n  }, [stressTestActive]);\r\n\r\n  return {\r\n    // State\r\n    isRunning,\r\n    tick,\r\n    systemStatus,\r\n    resources,\r\n    customers,\r\n    eventLog,\r\n    perfData,\r\n    stressData,\r\n    graphData,\r\n    deadlockCount,\r\n    recoveryCount,\r\n    totalGranted,\r\n    totalDenied,\r\n    stressTestActive,\r\n    preventionEnabled,\r\n    avoidanceEnabled,\r\n    detectionEnabled,\r\n\r\n    // Actions\r\n    startSimulation,\r\n    stopSimulation,\r\n    resetSystem,\r\n    toggleStressTest,\r\n    setPreventionEnabled,\r\n    setAvoidanceEnabled,\r\n    setDetectionEnabled,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}