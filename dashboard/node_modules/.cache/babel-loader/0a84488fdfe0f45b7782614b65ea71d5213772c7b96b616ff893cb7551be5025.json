{"ast":null,"code":"import _objectSpread from\"C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState,useEffect,useCallback,useRef}from'react';import{generateInitialResources,generateInitialCustomers,generateEvent,generatePerformancePoint,generateWaitForGraph,generateStressData,randomPick,randomInt,EVENT_TYPES}from'../data/mockData';const TICK_INTERVAL=1200;const MAX_LOG_ENTRIES=200;const MAX_PERF_POINTS=60;const MAX_STRESS_POINTS=40;export function useSimulation(){const[isRunning,setIsRunning]=useState(false);const[tick,setTick]=useState(0);const tickRef=useRef(0);// Strategy toggles\nconst[preventionEnabled,setPreventionEnabled]=useState(false);const[avoidanceEnabled,setAvoidanceEnabled]=useState(false);const[detectionEnabled,setDetectionEnabled]=useState(true);const[stressTestActive,setStressTestActive]=useState(false);// Core state\nconst[resources,setResources]=useState(()=>generateInitialResources(8));const[customers,setCustomers]=useState(()=>generateInitialCustomers(6));const[eventLog,setEventLog]=useState([]);const[perfData,setPerfData]=useState([]);const[stressData,setStressData]=useState([]);const[graphData,setGraphData]=useState({nodes:[],edges:[]});// Aggregate metrics\nconst[systemStatus,setSystemStatus]=useState('idle');// idle, running, deadlock, recovery\nconst[deadlockCount,setDeadlockCount]=useState(0);const[recoveryCount,setRecoveryCount]=useState(0);const[totalGranted,setTotalGranted]=useState(0);const[totalDenied,setTotalDenied]=useState(0);const intervalRef=useRef(null);const simulateTick=useCallback(()=>{tickRef.current+=1;const currentTick=tickRef.current;setTick(currentTick);setCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));updated.forEach(c=>{if(c.state==='idle'&&Math.random()>0.4){c.state='running';}});return updated;});setResources(prevResources=>{setCustomers(prevCustomers=>{const res=prevResources.map(r=>_objectSpread(_objectSpread({},r),{},{waitingThreads:[]}));const custs=prevCustomers.map(c=>_objectSpread(_objectSpread({},c),{},{holding:[...c.holding]}));// Simulate resource allocation\ncusts.forEach(c=>{if(c.state==='running'||c.state==='waiting'){const availableRes=res.filter(r=>r.available&&!c.holding.includes(r.id));if(availableRes.length>0&&Math.random()>0.3){const target=randomPick(availableRes);target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}else if(Math.random()>0.5){const unavailable=res.filter(r=>!r.available&&!c.holding.includes(r.id));if(unavailable.length>0){const target=randomPick(unavailable);target.waitingThreads.push(c.name);c.waiting=target.id;c.state='waiting';}}}// Randomly release resources\nif(c.holding.length>0&&Math.random()>0.65){const releaseId=randomPick(c.holding);c.holding=c.holding.filter(id=>id!==releaseId);const released=res.find(r=>r.id===releaseId);if(released){released.available=true;released.owner=null;released.currentInstances=Math.max(0,released.currentInstances-1);}if(c.holding.length===0&&!c.waiting){c.state=Math.random()>0.3?'running':'idle';}}});setResources(res);return custs;});return prevResources;});// Determine deadlock occurrence\nconst shouldDeadlock=!preventionEnabled&&!avoidanceEnabled&&Math.random()>0.82;const isRecovering=shouldDeadlock&&detectionEnabled&&Math.random()>0.3;if(shouldDeadlock){setDeadlockCount(prev=>prev+1);setSystemStatus('deadlock');// Mark some customers as deadlocked\nsetCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));const waiting=updated.filter(c=>c.state==='waiting');if(waiting.length>=2){waiting.slice(0,2).forEach(c=>{c.state='deadlocked';});}return updated;});}else if(isRecovering){setRecoveryCount(prev=>prev+1);setSystemStatus('recovery');setTimeout(()=>setSystemStatus('running'),2000);setCustomers(prev=>prev.map(c=>c.state==='deadlocked'?_objectSpread(_objectSpread({},c),{},{state:'running',waiting:null}):c));}else{setSystemStatus(prev=>prev==='deadlock'||prev==='recovery'?'running':prev);if(currentTick>1)setSystemStatus('running');}// Generate events\nsetCustomers(prevCustomers=>{setResources(prevResources=>{const eventTypes=[EVENT_TYPES.REQUEST,EVENT_TYPES.ALLOCATE,EVENT_TYPES.RELEASE];if(shouldDeadlock)eventTypes.push(EVENT_TYPES.DEADLOCK,EVENT_TYPES.BLOCK);if(isRecovering)eventTypes.push(EVENT_TYPES.RECOVERY);const newEvents=[];const numEvents=randomInt(1,3);for(let i=0;i<numEvents;i++){newEvents.push(generateEvent(prevCustomers,prevResources,randomPick(eventTypes)));}setEventLog(prev=>[...newEvents,...prev].slice(0,MAX_LOG_ENTRIES));// Update metrics\nconst point=generatePerformancePoint(currentTick,stressTestActive);setPerfData(prev=>[...prev,point].slice(-MAX_PERF_POINTS));setTotalGranted(prev=>prev+point.granted);setTotalDenied(prev=>prev+point.denied);// Update graph\nsetGraphData(generateWaitForGraph(prevCustomers,prevResources));// Stress test data\nif(stressTestActive){setStressData(prev=>[...prev,generateStressData(currentTick)].slice(-MAX_STRESS_POINTS));}return prevResources;});return prevCustomers;});},[preventionEnabled,avoidanceEnabled,detectionEnabled,stressTestActive]);// Main simulation loop\nuseEffect(()=>{if(isRunning){intervalRef.current=setInterval(simulateTick,TICK_INTERVAL);}else{if(intervalRef.current)clearInterval(intervalRef.current);}return()=>{if(intervalRef.current)clearInterval(intervalRef.current);};},[isRunning,simulateTick]);// Mark cycle edges in graph when deadlock\nuseEffect(()=>{if(systemStatus==='deadlock'){setGraphData(prev=>{const edges=prev.edges.map(e=>_objectSpread({},e));// Mark waiting edges as cycle\nconst cycleEdges=edges.filter(e=>e.type==='waiting');if(cycleEdges.length>=2){cycleEdges.forEach(e=>{e.cycle=true;});}return _objectSpread(_objectSpread({},prev),{},{edges});});}},[systemStatus]);const startSimulation=useCallback(()=>{setIsRunning(true);setSystemStatus('running');},[]);const stopSimulation=useCallback(()=>{setIsRunning(false);setSystemStatus('idle');},[]);const resetSystem=useCallback(()=>{setIsRunning(false);tickRef.current=0;setTick(0);setResources(generateInitialResources(8));setCustomers(generateInitialCustomers(6));setEventLog([]);setPerfData([]);setStressData([]);setGraphData({nodes:[],edges:[]});setSystemStatus('idle');setDeadlockCount(0);setRecoveryCount(0);setTotalGranted(0);setTotalDenied(0);setStressTestActive(false);setPreventionEnabled(false);setAvoidanceEnabled(false);setDetectionEnabled(true);},[]);const toggleStressTest=useCallback(()=>{setStressTestActive(prev=>!prev);if(!stressTestActive){setStressData([]);// Increase customer count during stress\nsetCustomers(prev=>{if(prev.length<12){const extra=generateInitialCustomers(12).slice(prev.length);extra.forEach(c=>{c.state='running';});return[...prev,...extra];}return prev;});}},[stressTestActive]);return{// State\nisRunning,tick,systemStatus,resources,customers,eventLog,perfData,stressData,graphData,deadlockCount,recoveryCount,totalGranted,totalDenied,stressTestActive,preventionEnabled,avoidanceEnabled,detectionEnabled,// Actions\nstartSimulation,stopSimulation,resetSystem,toggleStressTest,setPreventionEnabled,setAvoidanceEnabled,setDetectionEnabled};}","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","generateInitialResources","generateInitialCustomers","generateEvent","generatePerformancePoint","generateWaitForGraph","generateStressData","randomPick","randomInt","EVENT_TYPES","TICK_INTERVAL","MAX_LOG_ENTRIES","MAX_PERF_POINTS","MAX_STRESS_POINTS","useSimulation","isRunning","setIsRunning","tick","setTick","tickRef","preventionEnabled","setPreventionEnabled","avoidanceEnabled","setAvoidanceEnabled","detectionEnabled","setDetectionEnabled","stressTestActive","setStressTestActive","resources","setResources","customers","setCustomers","eventLog","setEventLog","perfData","setPerfData","stressData","setStressData","graphData","setGraphData","nodes","edges","systemStatus","setSystemStatus","deadlockCount","setDeadlockCount","recoveryCount","setRecoveryCount","totalGranted","setTotalGranted","totalDenied","setTotalDenied","intervalRef","simulateTick","current","currentTick","prev","updated","map","c","_objectSpread","forEach","state","Math","random","prevResources","prevCustomers","res","r","waitingThreads","custs","holding","availableRes","filter","available","includes","id","length","target","owner","name","currentInstances","push","waiting","unavailable","releaseId","released","find","max","shouldDeadlock","isRecovering","slice","setTimeout","eventTypes","REQUEST","ALLOCATE","RELEASE","DEADLOCK","BLOCK","RECOVERY","newEvents","numEvents","i","point","granted","denied","setInterval","clearInterval","e","cycleEdges","type","cycle","startSimulation","stopSimulation","resetSystem","toggleStressTest","extra"],"sources":["C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/src/hooks/useSimulation.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n  generateInitialResources,\r\n  generateInitialCustomers,\r\n  generateEvent,\r\n  generatePerformancePoint,\r\n  generateWaitForGraph,\r\n  generateStressData,\r\n  randomPick,\r\n  randomInt,\r\n  EVENT_TYPES,\r\n} from '../data/mockData';\r\n\r\nconst TICK_INTERVAL = 1200;\r\nconst MAX_LOG_ENTRIES = 200;\r\nconst MAX_PERF_POINTS = 60;\r\nconst MAX_STRESS_POINTS = 40;\r\n\r\nexport function useSimulation() {\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const [tick, setTick] = useState(0);\r\n  const tickRef = useRef(0);\r\n\r\n  // Strategy toggles\r\n  const [preventionEnabled, setPreventionEnabled] = useState(false);\r\n  const [avoidanceEnabled, setAvoidanceEnabled] = useState(false);\r\n  const [detectionEnabled, setDetectionEnabled] = useState(true);\r\n  const [stressTestActive, setStressTestActive] = useState(false);\r\n\r\n  // Core state\r\n  const [resources, setResources] = useState(() => generateInitialResources(8));\r\n  const [customers, setCustomers] = useState(() => generateInitialCustomers(6));\r\n  const [eventLog, setEventLog] = useState([]);\r\n  const [perfData, setPerfData] = useState([]);\r\n  const [stressData, setStressData] = useState([]);\r\n  const [graphData, setGraphData] = useState({ nodes: [], edges: [] });\r\n\r\n  // Aggregate metrics\r\n  const [systemStatus, setSystemStatus] = useState('idle'); // idle, running, deadlock, recovery\r\n  const [deadlockCount, setDeadlockCount] = useState(0);\r\n  const [recoveryCount, setRecoveryCount] = useState(0);\r\n  const [totalGranted, setTotalGranted] = useState(0);\r\n  const [totalDenied, setTotalDenied] = useState(0);\r\n\r\n  const intervalRef = useRef(null);\r\n\r\n  const simulateTick = useCallback(() => {\r\n    tickRef.current += 1;\r\n    const currentTick = tickRef.current;\r\n    setTick(currentTick);\r\n\r\n    setCustomers((prev) => {\r\n      const updated = prev.map((c) => ({ ...c }));\r\n      updated.forEach((c) => {\r\n        if (c.state === 'idle' && Math.random() > 0.4) {\r\n          c.state = 'running';\r\n        }\r\n      });\r\n      return updated;\r\n    });\r\n\r\n    setResources((prevResources) => {\r\n      setCustomers((prevCustomers) => {\r\n        const res = prevResources.map((r) => ({ ...r, waitingThreads: [] }));\r\n        const custs = prevCustomers.map((c) => ({ ...c, holding: [...c.holding] }));\r\n\r\n        // Simulate resource allocation\r\n        custs.forEach((c) => {\r\n          if (c.state === 'running' || c.state === 'waiting') {\r\n            const availableRes = res.filter(\r\n              (r) => r.available && !c.holding.includes(r.id)\r\n            );\r\n            if (availableRes.length > 0 && Math.random() > 0.3) {\r\n              const target = randomPick(availableRes);\r\n              target.available = false;\r\n              target.owner = c.name;\r\n              target.currentInstances += 1;\r\n              c.holding.push(target.id);\r\n              c.waiting = null;\r\n              c.state = 'running';\r\n            } else if (Math.random() > 0.5) {\r\n              const unavailable = res.filter(\r\n                (r) => !r.available && !c.holding.includes(r.id)\r\n              );\r\n              if (unavailable.length > 0) {\r\n                const target = randomPick(unavailable);\r\n                target.waitingThreads.push(c.name);\r\n                c.waiting = target.id;\r\n                c.state = 'waiting';\r\n              }\r\n            }\r\n          }\r\n\r\n          // Randomly release resources\r\n          if (c.holding.length > 0 && Math.random() > 0.65) {\r\n            const releaseId = randomPick(c.holding);\r\n            c.holding = c.holding.filter((id) => id !== releaseId);\r\n            const released = res.find((r) => r.id === releaseId);\r\n            if (released) {\r\n              released.available = true;\r\n              released.owner = null;\r\n              released.currentInstances = Math.max(0, released.currentInstances - 1);\r\n            }\r\n            if (c.holding.length === 0 && !c.waiting) {\r\n              c.state = Math.random() > 0.3 ? 'running' : 'idle';\r\n            }\r\n          }\r\n        });\r\n\r\n        setResources(res);\r\n        return custs;\r\n      });\r\n      return prevResources;\r\n    });\r\n\r\n    // Determine deadlock occurrence\r\n    const shouldDeadlock = !preventionEnabled && !avoidanceEnabled && Math.random() > 0.82;\r\n    const isRecovering = shouldDeadlock && detectionEnabled && Math.random() > 0.3;\r\n\r\n    if (shouldDeadlock) {\r\n      setDeadlockCount((prev) => prev + 1);\r\n      setSystemStatus('deadlock');\r\n\r\n      // Mark some customers as deadlocked\r\n      setCustomers((prev) => {\r\n        const updated = prev.map((c) => ({ ...c }));\r\n        const waiting = updated.filter((c) => c.state === 'waiting');\r\n        if (waiting.length >= 2) {\r\n          waiting.slice(0, 2).forEach((c) => {\r\n            c.state = 'deadlocked';\r\n          });\r\n        }\r\n        return updated;\r\n      });\r\n    } else if (isRecovering) {\r\n      setRecoveryCount((prev) => prev + 1);\r\n      setSystemStatus('recovery');\r\n      setTimeout(() => setSystemStatus('running'), 2000);\r\n\r\n      setCustomers((prev) =>\r\n        prev.map((c) => (c.state === 'deadlocked' ? { ...c, state: 'running', waiting: null } : c))\r\n      );\r\n    } else {\r\n      setSystemStatus((prev) => (prev === 'deadlock' || prev === 'recovery' ? 'running' : prev));\r\n      if (currentTick > 1) setSystemStatus('running');\r\n    }\r\n\r\n    // Generate events\r\n    setCustomers((prevCustomers) => {\r\n      setResources((prevResources) => {\r\n        const eventTypes = [EVENT_TYPES.REQUEST, EVENT_TYPES.ALLOCATE, EVENT_TYPES.RELEASE];\r\n        if (shouldDeadlock) eventTypes.push(EVENT_TYPES.DEADLOCK, EVENT_TYPES.BLOCK);\r\n        if (isRecovering) eventTypes.push(EVENT_TYPES.RECOVERY);\r\n\r\n        const newEvents = [];\r\n        const numEvents = randomInt(1, 3);\r\n        for (let i = 0; i < numEvents; i++) {\r\n          newEvents.push(generateEvent(prevCustomers, prevResources, randomPick(eventTypes)));\r\n        }\r\n\r\n        setEventLog((prev) => [...newEvents, ...prev].slice(0, MAX_LOG_ENTRIES));\r\n\r\n        // Update metrics\r\n        const point = generatePerformancePoint(currentTick, stressTestActive);\r\n        setPerfData((prev) => [...prev, point].slice(-MAX_PERF_POINTS));\r\n        setTotalGranted((prev) => prev + point.granted);\r\n        setTotalDenied((prev) => prev + point.denied);\r\n\r\n        // Update graph\r\n        setGraphData(generateWaitForGraph(prevCustomers, prevResources));\r\n\r\n        // Stress test data\r\n        if (stressTestActive) {\r\n          setStressData((prev) => [...prev, generateStressData(currentTick)].slice(-MAX_STRESS_POINTS));\r\n        }\r\n\r\n        return prevResources;\r\n      });\r\n      return prevCustomers;\r\n    });\r\n  }, [preventionEnabled, avoidanceEnabled, detectionEnabled, stressTestActive]);\r\n\r\n  // Main simulation loop\r\n  useEffect(() => {\r\n    if (isRunning) {\r\n      intervalRef.current = setInterval(simulateTick, TICK_INTERVAL);\r\n    } else {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    }\r\n    return () => {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    };\r\n  }, [isRunning, simulateTick]);\r\n\r\n  // Mark cycle edges in graph when deadlock\r\n  useEffect(() => {\r\n    if (systemStatus === 'deadlock') {\r\n      setGraphData((prev) => {\r\n        const edges = prev.edges.map((e) => ({ ...e }));\r\n        // Mark waiting edges as cycle\r\n        const cycleEdges = edges.filter((e) => e.type === 'waiting');\r\n        if (cycleEdges.length >= 2) {\r\n          cycleEdges.forEach((e) => {\r\n            e.cycle = true;\r\n          });\r\n        }\r\n        return { ...prev, edges };\r\n      });\r\n    }\r\n  }, [systemStatus]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsRunning(true);\r\n    setSystemStatus('running');\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsRunning(false);\r\n    setSystemStatus('idle');\r\n  }, []);\r\n\r\n  const resetSystem = useCallback(() => {\r\n    setIsRunning(false);\r\n    tickRef.current = 0;\r\n    setTick(0);\r\n    setResources(generateInitialResources(8));\r\n    setCustomers(generateInitialCustomers(6));\r\n    setEventLog([]);\r\n    setPerfData([]);\r\n    setStressData([]);\r\n    setGraphData({ nodes: [], edges: [] });\r\n    setSystemStatus('idle');\r\n    setDeadlockCount(0);\r\n    setRecoveryCount(0);\r\n    setTotalGranted(0);\r\n    setTotalDenied(0);\r\n    setStressTestActive(false);\r\n    setPreventionEnabled(false);\r\n    setAvoidanceEnabled(false);\r\n    setDetectionEnabled(true);\r\n  }, []);\r\n\r\n  const toggleStressTest = useCallback(() => {\r\n    setStressTestActive((prev) => !prev);\r\n    if (!stressTestActive) {\r\n      setStressData([]);\r\n      // Increase customer count during stress\r\n      setCustomers((prev) => {\r\n        if (prev.length < 12) {\r\n          const extra = generateInitialCustomers(12).slice(prev.length);\r\n          extra.forEach((c) => { c.state = 'running'; });\r\n          return [...prev, ...extra];\r\n        }\r\n        return prev;\r\n      });\r\n    }\r\n  }, [stressTestActive]);\r\n\r\n  return {\r\n    // State\r\n    isRunning,\r\n    tick,\r\n    systemStatus,\r\n    resources,\r\n    customers,\r\n    eventLog,\r\n    perfData,\r\n    stressData,\r\n    graphData,\r\n    deadlockCount,\r\n    recoveryCount,\r\n    totalGranted,\r\n    totalDenied,\r\n    stressTestActive,\r\n    preventionEnabled,\r\n    avoidanceEnabled,\r\n    detectionEnabled,\r\n\r\n    // Actions\r\n    startSimulation,\r\n    stopSimulation,\r\n    resetSystem,\r\n    toggleStressTest,\r\n    setPreventionEnabled,\r\n    setAvoidanceEnabled,\r\n    setDetectionEnabled,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}