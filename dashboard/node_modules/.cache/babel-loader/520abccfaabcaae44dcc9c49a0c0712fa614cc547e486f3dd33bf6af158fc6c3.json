{"ast":null,"code":"import _objectSpread from\"C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useState,useEffect,useCallback,useRef}from'react';import{generateInitialResources,generateInitialCustomers,generateEvent,generatePerformancePoint,generateWaitForGraph,generateStressData,randomPick,randomInt,EVENT_TYPES}from'../data/mockData';const TICK_INTERVAL=1200;const MAX_LOG_ENTRIES=200;const MAX_PERF_POINTS=60;const MAX_STRESS_POINTS=40;export function useSimulation(){const[isRunning,setIsRunning]=useState(false);const[tick,setTick]=useState(0);const tickRef=useRef(0);// Strategy toggles\nconst[preventionEnabled,setPreventionEnabled]=useState(false);const[avoidanceEnabled,setAvoidanceEnabled]=useState(false);const[detectionEnabled,setDetectionEnabled]=useState(true);const[stressTestActive,setStressTestActive]=useState(false);const[stressLevel,setStressLevel]=useState(5);// 1-10 scale\n// Active resource filter (empty Set = all active)\nconst[activeResourceIds,setActiveResourceIds]=useState(new Set());// Core state\nconst[resources,setResources]=useState(()=>generateInitialResources(8));const[customers,setCustomers]=useState(()=>generateInitialCustomers(6));const[eventLog,setEventLog]=useState([]);const[perfData,setPerfData]=useState([]);const[stressData,setStressData]=useState([]);const[graphData,setGraphData]=useState({nodes:[],edges:[]});// Aggregate metrics\nconst[systemStatus,setSystemStatus]=useState('idle');// idle, running, deadlock, recovery\nconst[deadlockCount,setDeadlockCount]=useState(0);const[recoveryCount,setRecoveryCount]=useState(0);const[totalGranted,setTotalGranted]=useState(0);const[totalDenied,setTotalDenied]=useState(0);const intervalRef=useRef(null);const simulateTick=useCallback(()=>{tickRef.current+=1;const currentTick=tickRef.current;setTick(currentTick);setCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));updated.forEach(c=>{if(c.state==='idle'&&Math.random()>0.4){c.state='running';}});return updated;});setResources(prevResources=>{setCustomers(prevCustomers=>{const res=prevResources.map(r=>_objectSpread(_objectSpread({},r),{},{waitingThreads:[]}));const custs=prevCustomers.map(c=>_objectSpread(_objectSpread({},c),{},{holding:[...c.holding]}));// Determine which resources are active (empty set = all)\nconst activeSet=activeResourceIds;const isResActive=r=>activeSet.size===0||activeSet.has(r.id);// Simulate resource allocation\ncusts.forEach(c=>{if(c.state==='running'||c.state==='waiting'){const availableRes=res.filter(r=>isResActive(r)&&r.available&&!c.holding.includes(r.id));if(availableRes.length>0&&Math.random()>0.3){const target=randomPick(availableRes);target.available=false;target.owner=c.name;target.currentInstances+=1;c.holding.push(target.id);c.waiting=null;c.state='running';}else if(Math.random()>0.5){const unavailable=res.filter(r=>isResActive(r)&&!r.available&&!c.holding.includes(r.id));if(unavailable.length>0){const target=randomPick(unavailable);target.waitingThreads.push(c.name);c.waiting=target.id;c.state='waiting';}}}// Randomly release resources\nif(c.holding.length>0&&Math.random()>0.65){const releaseId=randomPick(c.holding);c.holding=c.holding.filter(id=>id!==releaseId);const released=res.find(r=>r.id===releaseId);if(released){released.available=true;released.owner=null;released.currentInstances=Math.max(0,released.currentInstances-1);}if(c.holding.length===0&&!c.waiting){c.state=Math.random()>0.3?'running':'idle';}}});setResources(res);return custs;});return prevResources;});// Determine deadlock occurrence\nconst shouldDeadlock=!preventionEnabled&&!avoidanceEnabled&&Math.random()>0.82;const isRecovering=shouldDeadlock&&detectionEnabled&&Math.random()>0.3;if(shouldDeadlock){setDeadlockCount(prev=>prev+1);setSystemStatus('deadlock');// Mark some customers as deadlocked\nsetCustomers(prev=>{const updated=prev.map(c=>_objectSpread({},c));const waiting=updated.filter(c=>c.state==='waiting');if(waiting.length>=2){waiting.slice(0,2).forEach(c=>{c.state='deadlocked';});}return updated;});}else if(isRecovering){setRecoveryCount(prev=>prev+1);setSystemStatus('recovery');setTimeout(()=>setSystemStatus('running'),2000);setCustomers(prev=>prev.map(c=>c.state==='deadlocked'?_objectSpread(_objectSpread({},c),{},{state:'running',waiting:null}):c));}else{setSystemStatus(prev=>prev==='deadlock'||prev==='recovery'?'running':prev);if(currentTick>1)setSystemStatus('running');}// Generate events\nsetCustomers(prevCustomers=>{setResources(prevResources=>{const eventTypes=[EVENT_TYPES.REQUEST,EVENT_TYPES.ALLOCATE,EVENT_TYPES.RELEASE];if(shouldDeadlock)eventTypes.push(EVENT_TYPES.DEADLOCK,EVENT_TYPES.BLOCK);if(isRecovering)eventTypes.push(EVENT_TYPES.RECOVERY);const newEvents=[];const numEvents=randomInt(1,3);for(let i=0;i<numEvents;i++){newEvents.push(generateEvent(prevCustomers,prevResources,randomPick(eventTypes)));}setEventLog(prev=>[...newEvents,...prev].slice(0,MAX_LOG_ENTRIES));// Update metrics\nconst point=generatePerformancePoint(currentTick,stressTestActive);setPerfData(prev=>[...prev,point].slice(-MAX_PERF_POINTS));setTotalGranted(prev=>prev+point.granted);setTotalDenied(prev=>prev+point.denied);// Update graph\nsetGraphData(generateWaitForGraph(prevCustomers,prevResources));// Stress test data\nif(stressTestActive){setStressData(prev=>[...prev,generateStressData(currentTick,stressLevel)].slice(-MAX_STRESS_POINTS));}return prevResources;});return prevCustomers;});},[preventionEnabled,avoidanceEnabled,detectionEnabled,stressTestActive,stressLevel,activeResourceIds]);// Main simulation loop\nuseEffect(()=>{if(isRunning){intervalRef.current=setInterval(simulateTick,TICK_INTERVAL);}else{if(intervalRef.current)clearInterval(intervalRef.current);}return()=>{if(intervalRef.current)clearInterval(intervalRef.current);};},[isRunning,simulateTick]);// Mark cycle edges in graph when deadlock\nuseEffect(()=>{if(systemStatus==='deadlock'){setGraphData(prev=>{const edges=prev.edges.map(e=>_objectSpread({},e));// Mark waiting edges as cycle\nconst cycleEdges=edges.filter(e=>e.type==='waiting');if(cycleEdges.length>=2){cycleEdges.forEach(e=>{e.cycle=true;});}return _objectSpread(_objectSpread({},prev),{},{edges});});}},[systemStatus]);const startSimulation=useCallback(()=>{setIsRunning(true);setSystemStatus('running');},[]);const stopSimulation=useCallback(()=>{setIsRunning(false);setSystemStatus('idle');},[]);const resetSystem=useCallback(()=>{setIsRunning(false);tickRef.current=0;setTick(0);setResources(generateInitialResources(8));setCustomers(generateInitialCustomers(6));setEventLog([]);setPerfData([]);setStressData([]);setGraphData({nodes:[],edges:[]});setSystemStatus('idle');setDeadlockCount(0);setRecoveryCount(0);setTotalGranted(0);setTotalDenied(0);setStressTestActive(false);setStressLevel(5);setActiveResourceIds(new Set());setPreventionEnabled(false);setAvoidanceEnabled(false);setDetectionEnabled(true);},[]);const toggleStressTest=useCallback(()=>{setStressTestActive(prev=>!prev);if(!stressTestActive){setStressData([]);// Increase customer count during stress\nsetCustomers(prev=>{if(prev.length<12){const extra=generateInitialCustomers(12).slice(prev.length);extra.forEach(c=>{c.state='running';});return[...prev,...extra];}return prev;});}},[stressTestActive]);const adjustStressLevel=useCallback(delta=>{setStressLevel(prev=>Math.max(1,Math.min(10,prev+delta)));},[]);const toggleResourceActive=useCallback(resourceId=>{setActiveResourceIds(prev=>{const next=new Set(prev);if(next.has(resourceId)){next.delete(resourceId);}else{next.add(resourceId);}return next;});},[]);const clearResourceFilter=useCallback(()=>{setActiveResourceIds(new Set());},[]);return{// State\nisRunning,tick,systemStatus,resources,customers,eventLog,perfData,stressData,graphData,deadlockCount,recoveryCount,totalGranted,totalDenied,stressTestActive,stressLevel,activeResourceIds,preventionEnabled,avoidanceEnabled,detectionEnabled,// Actions\nstartSimulation,stopSimulation,resetSystem,toggleStressTest,adjustStressLevel,toggleResourceActive,clearResourceFilter,setPreventionEnabled,setAvoidanceEnabled,setDetectionEnabled};}","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","generateInitialResources","generateInitialCustomers","generateEvent","generatePerformancePoint","generateWaitForGraph","generateStressData","randomPick","randomInt","EVENT_TYPES","TICK_INTERVAL","MAX_LOG_ENTRIES","MAX_PERF_POINTS","MAX_STRESS_POINTS","useSimulation","isRunning","setIsRunning","tick","setTick","tickRef","preventionEnabled","setPreventionEnabled","avoidanceEnabled","setAvoidanceEnabled","detectionEnabled","setDetectionEnabled","stressTestActive","setStressTestActive","stressLevel","setStressLevel","activeResourceIds","setActiveResourceIds","Set","resources","setResources","customers","setCustomers","eventLog","setEventLog","perfData","setPerfData","stressData","setStressData","graphData","setGraphData","nodes","edges","systemStatus","setSystemStatus","deadlockCount","setDeadlockCount","recoveryCount","setRecoveryCount","totalGranted","setTotalGranted","totalDenied","setTotalDenied","intervalRef","simulateTick","current","currentTick","prev","updated","map","c","_objectSpread","forEach","state","Math","random","prevResources","prevCustomers","res","r","waitingThreads","custs","holding","activeSet","isResActive","size","has","id","availableRes","filter","available","includes","length","target","owner","name","currentInstances","push","waiting","unavailable","releaseId","released","find","max","shouldDeadlock","isRecovering","slice","setTimeout","eventTypes","REQUEST","ALLOCATE","RELEASE","DEADLOCK","BLOCK","RECOVERY","newEvents","numEvents","i","point","granted","denied","setInterval","clearInterval","e","cycleEdges","type","cycle","startSimulation","stopSimulation","resetSystem","toggleStressTest","extra","adjustStressLevel","delta","min","toggleResourceActive","resourceId","next","delete","add","clearResourceFilter"],"sources":["C:/Users/suchindra/Downloads/Deadlock_Online_Shopping/dashboard/src/hooks/useSimulation.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\nimport {\r\n  generateInitialResources,\r\n  generateInitialCustomers,\r\n  generateEvent,\r\n  generatePerformancePoint,\r\n  generateWaitForGraph,\r\n  generateStressData,\r\n  randomPick,\r\n  randomInt,\r\n  EVENT_TYPES,\r\n} from '../data/mockData';\r\n\r\nconst TICK_INTERVAL = 1200;\r\nconst MAX_LOG_ENTRIES = 200;\r\nconst MAX_PERF_POINTS = 60;\r\nconst MAX_STRESS_POINTS = 40;\r\n\r\nexport function useSimulation() {\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const [tick, setTick] = useState(0);\r\n  const tickRef = useRef(0);\r\n\r\n  // Strategy toggles\r\n  const [preventionEnabled, setPreventionEnabled] = useState(false);\r\n  const [avoidanceEnabled, setAvoidanceEnabled] = useState(false);\r\n  const [detectionEnabled, setDetectionEnabled] = useState(true);\r\n  const [stressTestActive, setStressTestActive] = useState(false);\r\n  const [stressLevel, setStressLevel] = useState(5); // 1-10 scale\r\n\r\n  // Active resource filter (empty Set = all active)\r\n  const [activeResourceIds, setActiveResourceIds] = useState(new Set());\r\n\r\n  // Core state\r\n  const [resources, setResources] = useState(() => generateInitialResources(8));\r\n  const [customers, setCustomers] = useState(() => generateInitialCustomers(6));\r\n  const [eventLog, setEventLog] = useState([]);\r\n  const [perfData, setPerfData] = useState([]);\r\n  const [stressData, setStressData] = useState([]);\r\n  const [graphData, setGraphData] = useState({ nodes: [], edges: [] });\r\n\r\n  // Aggregate metrics\r\n  const [systemStatus, setSystemStatus] = useState('idle'); // idle, running, deadlock, recovery\r\n  const [deadlockCount, setDeadlockCount] = useState(0);\r\n  const [recoveryCount, setRecoveryCount] = useState(0);\r\n  const [totalGranted, setTotalGranted] = useState(0);\r\n  const [totalDenied, setTotalDenied] = useState(0);\r\n\r\n  const intervalRef = useRef(null);\r\n\r\n  const simulateTick = useCallback(() => {\r\n    tickRef.current += 1;\r\n    const currentTick = tickRef.current;\r\n    setTick(currentTick);\r\n\r\n    setCustomers((prev) => {\r\n      const updated = prev.map((c) => ({ ...c }));\r\n      updated.forEach((c) => {\r\n        if (c.state === 'idle' && Math.random() > 0.4) {\r\n          c.state = 'running';\r\n        }\r\n      });\r\n      return updated;\r\n    });\r\n\r\n    setResources((prevResources) => {\r\n      setCustomers((prevCustomers) => {\r\n        const res = prevResources.map((r) => ({ ...r, waitingThreads: [] }));\r\n        const custs = prevCustomers.map((c) => ({ ...c, holding: [...c.holding] }));\r\n\r\n        // Determine which resources are active (empty set = all)\r\n        const activeSet = activeResourceIds;\r\n        const isResActive = (r) => activeSet.size === 0 || activeSet.has(r.id);\r\n\r\n        // Simulate resource allocation\r\n        custs.forEach((c) => {\r\n          if (c.state === 'running' || c.state === 'waiting') {\r\n            const availableRes = res.filter(\r\n              (r) => isResActive(r) && r.available && !c.holding.includes(r.id)\r\n            );\r\n            if (availableRes.length > 0 && Math.random() > 0.3) {\r\n              const target = randomPick(availableRes);\r\n              target.available = false;\r\n              target.owner = c.name;\r\n              target.currentInstances += 1;\r\n              c.holding.push(target.id);\r\n              c.waiting = null;\r\n              c.state = 'running';\r\n            } else if (Math.random() > 0.5) {\r\n              const unavailable = res.filter(\r\n                (r) => isResActive(r) && !r.available && !c.holding.includes(r.id)\r\n              );\r\n              if (unavailable.length > 0) {\r\n                const target = randomPick(unavailable);\r\n                target.waitingThreads.push(c.name);\r\n                c.waiting = target.id;\r\n                c.state = 'waiting';\r\n              }\r\n            }\r\n          }\r\n\r\n          // Randomly release resources\r\n          if (c.holding.length > 0 && Math.random() > 0.65) {\r\n            const releaseId = randomPick(c.holding);\r\n            c.holding = c.holding.filter((id) => id !== releaseId);\r\n            const released = res.find((r) => r.id === releaseId);\r\n            if (released) {\r\n              released.available = true;\r\n              released.owner = null;\r\n              released.currentInstances = Math.max(0, released.currentInstances - 1);\r\n            }\r\n            if (c.holding.length === 0 && !c.waiting) {\r\n              c.state = Math.random() > 0.3 ? 'running' : 'idle';\r\n            }\r\n          }\r\n        });\r\n\r\n        setResources(res);\r\n        return custs;\r\n      });\r\n      return prevResources;\r\n    });\r\n\r\n    // Determine deadlock occurrence\r\n    const shouldDeadlock = !preventionEnabled && !avoidanceEnabled && Math.random() > 0.82;\r\n    const isRecovering = shouldDeadlock && detectionEnabled && Math.random() > 0.3;\r\n\r\n    if (shouldDeadlock) {\r\n      setDeadlockCount((prev) => prev + 1);\r\n      setSystemStatus('deadlock');\r\n\r\n      // Mark some customers as deadlocked\r\n      setCustomers((prev) => {\r\n        const updated = prev.map((c) => ({ ...c }));\r\n        const waiting = updated.filter((c) => c.state === 'waiting');\r\n        if (waiting.length >= 2) {\r\n          waiting.slice(0, 2).forEach((c) => {\r\n            c.state = 'deadlocked';\r\n          });\r\n        }\r\n        return updated;\r\n      });\r\n    } else if (isRecovering) {\r\n      setRecoveryCount((prev) => prev + 1);\r\n      setSystemStatus('recovery');\r\n      setTimeout(() => setSystemStatus('running'), 2000);\r\n\r\n      setCustomers((prev) =>\r\n        prev.map((c) => (c.state === 'deadlocked' ? { ...c, state: 'running', waiting: null } : c))\r\n      );\r\n    } else {\r\n      setSystemStatus((prev) => (prev === 'deadlock' || prev === 'recovery' ? 'running' : prev));\r\n      if (currentTick > 1) setSystemStatus('running');\r\n    }\r\n\r\n    // Generate events\r\n    setCustomers((prevCustomers) => {\r\n      setResources((prevResources) => {\r\n        const eventTypes = [EVENT_TYPES.REQUEST, EVENT_TYPES.ALLOCATE, EVENT_TYPES.RELEASE];\r\n        if (shouldDeadlock) eventTypes.push(EVENT_TYPES.DEADLOCK, EVENT_TYPES.BLOCK);\r\n        if (isRecovering) eventTypes.push(EVENT_TYPES.RECOVERY);\r\n\r\n        const newEvents = [];\r\n        const numEvents = randomInt(1, 3);\r\n        for (let i = 0; i < numEvents; i++) {\r\n          newEvents.push(generateEvent(prevCustomers, prevResources, randomPick(eventTypes)));\r\n        }\r\n\r\n        setEventLog((prev) => [...newEvents, ...prev].slice(0, MAX_LOG_ENTRIES));\r\n\r\n        // Update metrics\r\n        const point = generatePerformancePoint(currentTick, stressTestActive);\r\n        setPerfData((prev) => [...prev, point].slice(-MAX_PERF_POINTS));\r\n        setTotalGranted((prev) => prev + point.granted);\r\n        setTotalDenied((prev) => prev + point.denied);\r\n\r\n        // Update graph\r\n        setGraphData(generateWaitForGraph(prevCustomers, prevResources));\r\n\r\n        // Stress test data\r\n        if (stressTestActive) {\r\n          setStressData((prev) => [...prev, generateStressData(currentTick, stressLevel)].slice(-MAX_STRESS_POINTS));\r\n        }\r\n\r\n        return prevResources;\r\n      });\r\n      return prevCustomers;\r\n    });\r\n  }, [preventionEnabled, avoidanceEnabled, detectionEnabled, stressTestActive, stressLevel, activeResourceIds]);\r\n\r\n  // Main simulation loop\r\n  useEffect(() => {\r\n    if (isRunning) {\r\n      intervalRef.current = setInterval(simulateTick, TICK_INTERVAL);\r\n    } else {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    }\r\n    return () => {\r\n      if (intervalRef.current) clearInterval(intervalRef.current);\r\n    };\r\n  }, [isRunning, simulateTick]);\r\n\r\n  // Mark cycle edges in graph when deadlock\r\n  useEffect(() => {\r\n    if (systemStatus === 'deadlock') {\r\n      setGraphData((prev) => {\r\n        const edges = prev.edges.map((e) => ({ ...e }));\r\n        // Mark waiting edges as cycle\r\n        const cycleEdges = edges.filter((e) => e.type === 'waiting');\r\n        if (cycleEdges.length >= 2) {\r\n          cycleEdges.forEach((e) => {\r\n            e.cycle = true;\r\n          });\r\n        }\r\n        return { ...prev, edges };\r\n      });\r\n    }\r\n  }, [systemStatus]);\r\n\r\n  const startSimulation = useCallback(() => {\r\n    setIsRunning(true);\r\n    setSystemStatus('running');\r\n  }, []);\r\n\r\n  const stopSimulation = useCallback(() => {\r\n    setIsRunning(false);\r\n    setSystemStatus('idle');\r\n  }, []);\r\n\r\n  const resetSystem = useCallback(() => {\r\n    setIsRunning(false);\r\n    tickRef.current = 0;\r\n    setTick(0);\r\n    setResources(generateInitialResources(8));\r\n    setCustomers(generateInitialCustomers(6));\r\n    setEventLog([]);\r\n    setPerfData([]);\r\n    setStressData([]);\r\n    setGraphData({ nodes: [], edges: [] });\r\n    setSystemStatus('idle');\r\n    setDeadlockCount(0);\r\n    setRecoveryCount(0);\r\n    setTotalGranted(0);\r\n    setTotalDenied(0);\r\n    setStressTestActive(false);\r\n    setStressLevel(5);\r\n    setActiveResourceIds(new Set());\r\n    setPreventionEnabled(false);\r\n    setAvoidanceEnabled(false);\r\n    setDetectionEnabled(true);\r\n  }, []);\r\n\r\n  const toggleStressTest = useCallback(() => {\r\n    setStressTestActive((prev) => !prev);\r\n    if (!stressTestActive) {\r\n      setStressData([]);\r\n      // Increase customer count during stress\r\n      setCustomers((prev) => {\r\n        if (prev.length < 12) {\r\n          const extra = generateInitialCustomers(12).slice(prev.length);\r\n          extra.forEach((c) => { c.state = 'running'; });\r\n          return [...prev, ...extra];\r\n        }\r\n        return prev;\r\n      });\r\n    }\r\n  }, [stressTestActive]);\r\n\r\n  const adjustStressLevel = useCallback((delta) => {\r\n    setStressLevel((prev) => Math.max(1, Math.min(10, prev + delta)));\r\n  }, []);\r\n\r\n  const toggleResourceActive = useCallback((resourceId) => {\r\n    setActiveResourceIds((prev) => {\r\n      const next = new Set(prev);\r\n      if (next.has(resourceId)) {\r\n        next.delete(resourceId);\r\n      } else {\r\n        next.add(resourceId);\r\n      }\r\n      return next;\r\n    });\r\n  }, []);\r\n\r\n  const clearResourceFilter = useCallback(() => {\r\n    setActiveResourceIds(new Set());\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    isRunning,\r\n    tick,\r\n    systemStatus,\r\n    resources,\r\n    customers,\r\n    eventLog,\r\n    perfData,\r\n    stressData,\r\n    graphData,\r\n    deadlockCount,\r\n    recoveryCount,\r\n    totalGranted,\r\n    totalDenied,\r\n    stressTestActive,\r\n    stressLevel,\r\n    activeResourceIds,\r\n    preventionEnabled,\r\n    avoidanceEnabled,\r\n    detectionEnabled,\r\n\r\n    // Actions\r\n    startSimulation,\r\n    stopSimulation,\r\n    resetSystem,\r\n    toggleStressTest,\r\n    adjustStressLevel,\r\n    toggleResourceActive,\r\n    clearResourceFilter,\r\n    setPreventionEnabled,\r\n    setAvoidanceEnabled,\r\n    setDetectionEnabled,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}